## Kubernetes 사용시 무중단 배포의 종류

오늘 쓰는 글은 개념 설명 만 적었다. 이해만 하기 위한 글이다. ArgoCD 의 Rollout 을 사용하는 글은 이번주 토요일,일요일, 월요일이 되어야 예제가 얼추 만들어질 것 같다.<br>

<br>



개발자들은 서비스의 일부 기능이 장애가 나지 않도록 인스턴스 종료 직전 가장 마지막으로 들어온 요청 까지만 처리하고 그 이후의 요청부터는 받지 않는 우아한 종료에 관련된 이야기를 많이 들었고 다중 인스턴스로 운영되는 개발환경에 이런 점들을 적용해오는 경우가 많다. 오늘 이야기는 이런 소프트웨어적인 관점이 아닌 운영 및 인프라 레벨에서의 이야기이다. <br>

전체적인 요지는 **"서비스를 운영하는 입장에서 무중단 배포를 할 때 어떤 종류의 전략을 취하는가?"**에 대한 이야기이다.<br>

항상 이런 문서를 정리하다보면, **"개발자 레벨에서 투머치하게 이해하려고 하는 건가?"** 하고 나 자신을 의심할 때가 자주 있다. 그런데 이 내용은 개발자도 일부 알아야 한다. 데브옵스나 인프라 팀 계열의 엔지니어는 이런 개념을 토대로 자원을 관리하고 비용을 관리하고 계획을 세우는 분들이라면, 개발자 입장에서는 이런 것들을 아무것도 없는 상태에서 어느 정도 선 까지는 만들어서 개발 버전에서 운영할 수 있는 정도는 구축이 가능해야 k8s 환경에서의 개발환경에 대응이 가능하지 않을까 싶다.<br>

<br>



## 참고

- [Argo CD 를 이용한 다양한 배포방식을 지원하는 라이브러리 : Argo Rollouts](https://medium.com/finda-tech/argo-cd%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EB%8B%A4%EC%96%91%ED%95%9C-%EB%B0%B0%ED%8F%AC-%EB%B0%A9%EC%8B%9D%EC%9D%84-%EC%A7%80%EC%9B%90%ED%95%98%EB%8A%94-%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC-argo-rollouts-3a205abf7261)
- [배포 전략의 종류 (롤링/블루,그린/카나리)](https://reference-m1.tistory.com/211?source=post_page-----3a205abf7261--------------------------------)
- [롤링 업데이트 (Rolling Update) 무중단 배포](https://ooeunz.tistory.com/124)

<br>



## 무중단 배포란 ?

서버를 실제로 서비스 할 때 새로운 버전의 서비스를 배포 시에 구 버전의 서비스가 중단되지 않도록 하고 일시 중단으로 인한 장애가 발생하지 않도록 하는 배포 방식이다.<br>

쿠버네티스는 이러한 무중단 배포를 지원한다. 대표적으로 블루/그린(Blue/Green) 배포, 롤링 업데이트(Rolling Update) 배포, 카나리(Canary) 배포 방식을 예로 들 수 있다.<br>

- 블루 그린 (Blue/Green) 방식
- 카나리 (Canary) 방식
- 롤링 업데이트 (Rolling Update) 방식

<br>



흔히 Nginx 를 이용해서 무중단 배포를 하는 등의 글들이 인터넷에 많이 돌아다니는데, 이번에 알아볼 무중단 배포 방식은 쿠버네티스에서 채택하는 무중단 배포 방식들이다.<br>

<br>



## 쿠버네티스에서 적용 가능한 배포 방식들

**쿠버네티스**에서 무중단 배포 방식 들 중 가장 많이 사용되는 방식은 **롤링 업데이트 (Rolling Update)** 방식이다.<br>

**ArgoCD** 를 사용할 경우 흔히 **Argo Rollouts** 이라고 하는 Argo 진영의 라이브러리를 사용하면 블루/그린(Blue/Green) 방식, 카나리(Canary) 방식의 배포를 모두 지원가능해진다.<br>

Argo CD 의 Argo Rollouts 가 지원하는 배포방식들<br>

- 블루/그린 (Blue/Green) 방식
- 카나리 (Canary) 방식

<br>



## Rolling Update, Blue/Green, Canary

### 롤링 업데이트 (Rolling Update) 배포 

롤링 업데이트 (Rolling Update) 배포 방식은 새로운 버전을 배포하면서 새로운 버전의 인스턴스를 하나씩 늘려가고 구버전의 인스턴스는 하나씩 줄여나가는 방식을 의미한다. 이 경우 새로운 버전의 인스턴스로 트래픽이 이관될 때 까지 구버전과 신규버전의 인스턴스가 동시에 존재한다는 단점은 있다. 하지만 시스템을 무중단으로 업데이트 할 수 있다는 장점이 있다.<br>

롤링 업데이트 (Rolling Update) 배포 방식은 시스템을 무중단으로 업데이트 할 수 있다는 장점이 있다. 하지만, 기존 버전의 인스턴스와 신규버전의 인스턴스가 동시에 존재하면서 이전 서비스로의 유입을 어느 정도는 허용해야 한다는 단점이 있다. 이 외에도 배포가 잘못되었을 경우 롤백을 하기 위해 순서를 거꾸로 실행해야 한다는 점은 불편한 점의 하나로 꼽힌다.<br>

<br>



장점

- 시스템을 무중단으로 업데이트 할 수 있다는 점

단점

- 기존 버전의 인스턴스와 신규 버전의 인스턴스가 동시에 존재하면서 이전 서비스로의 유입을 어느 정도는 허용해야 한다는 단점
- 배포가 잘못되었을 경우 롤백을 위해 순서를 거꾸로 실행해야 한다는 단점

<br>



### 롤링 업데이트 (Rolling Update) 배포 절차

`v1` 로 운영되고 있는 pod 3 개를 replica set 으로 하는 Deployment 가 배포되어 있는 상황이다. 그런데  `v2` 버전의 신 버전이 개발되었고 이것을 신 버전이 적용된 새로운 Pod 3기로 배포해야 한다. 이때 기존의 서비스에 영향을 주지 않으면서 중단 없이 배포 (무중단 배포)를 해야 하는 상황이다.

즉 구버전 서비스인 `v1` 의 pod 3기에 대해 신버전 서비스인 `v2` 버전의 pod 3개로 서비스 중단 없이 교체해야 하는 상황이다.

- 1\) `v2` 버전의 pod 1기가 준비되었다.  `v1` 버전의 pod 갯수를 3개에서 2개로 줄인다.
    - 현재 상태
        - `v1` : Pod 3개 → Pod 2개
        - `v2` : Pod 0개 → Pod 1개
- 2\) `v2` 버전의 pod 1기가 하나 더 준비되었다. `v1` 버전의 pod 갯수를 2 개에서 1개로 줄인다.
    - 현재 상태
        - `v1` : Pod 2개 → Pod 1개
        - `v2` : Pod 1개 → Pod 2개
- 3\) 마지막으로 `v2` 버전의 pod 1기가 하나 더 준비되었다. `v1` 버전의 pod 갯수를 1개에서 0 개로 줄인다.
    - 현재 상태
        - `v1` : Pod 1개 → Pod 0개
        - `v2` : Pod 2개 → Pod 3개

<br>



### 블루/그린 (Blue/Green) 배포

신버전의 서비스를 배포해야 할 때 이미 운영 중인 구 버전 인스턴스를 그대로 유지한 상태에서 신버전의 서비스와 동일한 규모로 신버전 서비스의 인스턴스들을 배포한다. 그리고 Load Balancer 가 보내주는 트래픽의 방향을 신버전 서비스의 모든 인스턴스들로 향하도록 한번에 바꿔준다. 

블루/그린 배포 방식은 운영환경에 큰 영향(Side Effect)를 발생시키지 않는다는 점에서 장점을 갖는다. 하지만, 배포 시 마다 구버전 서비스의 인스턴스 규모만큼 신버전 인스턴스들도 갖춰야 하기에 시스템 운영 자원을 두 배로 필요로 하게 되어 운영 비용이 높아진다는 단점이 있다.

운영 비용에 단점이 있기는 하지만, 이익이 꾸준히 나는 우수한 회사라면, 이런 비용에 대해 두려워하지 않고 블루/그린 배포를 하지 않을까 싶다.<br>

<br>



### 블루/그린 (Blue/Green) 배포 절차

`v1` 으로 운영되고 있는 pod 3 개를 Replica Set 으로 하는 Deployment 가 배포되어 있는 상황을 생각해보자. 그런데 `v2` 버전의 신 버전이 개발되었고 이것을 신 버전이 적용된 새로운 Pod 3기로 배포해야 한다. 이때 기존 서비스에 영향을 주지 않으면서 중단 없이 배포 (무중단 배포)를 해야 하는 상황이다.

즉 구버전 서비스인 `v1` 의 pod 3기에 대해 신버전 서비스인 `v2` 버전의 pod 3개로 서비스 중단 없이 교체해야 하는 상황이다.

- 1\) `v1` 버전의 pod 갯수는 현재 3기가 정상 운영중이다. `v2` 버전의 pod 은 아직 구동되지 않은 상태다.
    - 현재 상태
        - `v1` : Pod 3개 → Pod 3개 (유입 트래픽은 이곳으로 흐르는 중)
        - `v2` : Pod 0개 → Pod 0개
- 2\) `v2` 버전의 pod 3기와 `v1` 버전의 pod 3기 모두 함께 구동 중인 상태다. 이때 새로 유입되는 트래픽은 `v2` 버전의 pod 3 기로 흐르게끔 해둔 상황이다. `v1` 버전의 pod 3 기는 계속 대기 중인 상황이다.
- 현재 상태
    - `v1` : Pod 3개 → Pod 3개
    - `v2` : Pod 0개 → Pod 3개 (유입 트래픽은 이곳으로 흐르도록 전환됨)
- 3\) `v2` 버전의 서비스가 정상적으로 잘 띄워졌고, 잘 동작하는지를 체크 후 `v2` 가 정상이라고 판단된다면 `v1` 으로 배포되어 있는 Pod 3기를 종료시켜서 `v2` 버전의 인스턴스 3기만 운영환경에 배포되어 있도록 구성한다.
    - 현재 상태
        - `v1` : Pod 3개 → Pod 0개
        - `v2` : Pod 3개 → Pod 3개 (유입 트래픽은 이제부터 여기로 향하도록 고정)

<br>



### 카나리 (Canary) 배포

카나리 배포는 위험을 빠르게 감지하기 위한 배포 전략이다.<br>

카나리(Canary) 의 사전적 의미는 ‘카나리아’라는 새를 의미한다. 카나리아는 가스에 굉장히 민감한 동물인데, 석탄 광산에서 유독가스 누출을 감지하기 위해 광산에 같이 데리고 들어갔었다고 한다.<br>

트래픽의 일부를 새로운 버전으로 유입시켜서 조금씩 테스트 해본 후 오류 없이 정상적이라고 판단되면 트래픽의 전체를 새로운 버전에 유입되게끔 배포하는 방식이다.<br>

<br>



### 카나리 (Canary) 배포 절차

`v1` 으로 운영되고 있는 pod 3 개를 Replica Set 으로 하는 Deployment 가 배포되어 있는 상황을 생각해보자. 그런데 `v2` 버전의 신 버전이 개발되었고 이것을 신 버전이 적용된 새로운 Pod 3기로 배포해야 한다. 이때 기존 서비스에 영향을 주지 않으면서 중단 없이 배포 (무중단 배포)를 해야 하는 상황이다.

즉 구버전 서비스인 `v1` 의 pod 3기에 대해 신버전 서비스인 `v2` 버전의 pod 3개로 서비스 중단 없이 교체해야 하는 상황이다.

- 1\) `v1` 버전의 pod 개수는 현재 3기가 정상 운영 중이다. `v2` 버전은 아직 배포 준비중이며 아직 pod 은 구동되지 않은 상태다.
    - 현재 상태
        - `v1` : Pod 3 개 → Pod 3 개 (유입 트래픽은 이곳으로 흐르는 중)
        - `v2` : Pod 0 개 → Pod 0 개
- 2\) `v1` 버전은 원래 운영되던 3개의 Pod 들중 2개의 Pod 만 운영하고, `v2` 버전에 1기의 Pod 을 배포해서 `v1` 버전 Pod 2개, `v2` 버전 Pod 1 개를 배포해서 `v1` 버전은 2/3 , `v2` 버전은 1/3 의 트래픽이 유입되게끔 배포했다.
    - 현재 상태
        - `v1` : Pod 3 개 → Pod 2 개 (유입 트래픽 중 3/2 는 이곳으로 흐르는 중)
        - `v2` : Pod 0 개 → Pod 1 개 (유입 트래픽 중 3/1 은 이곳으로 흐르게 시험)
- 3\) 2) 에서 배포해둔 상태를 일정 기간 동안 유지한다.
    - 이상이 없는지 여부를 체크한다
    - 일정 기간 동안 유입된 트래픽을 통해서 A/B 테스트를 위한 데이터를 쌓아둔다.

일정 시간이 지난 후에는 아래와 같은 기준에 의해 `v2` 전환 여부를 결정한다.

- 오류가 없다면 `v1` 의 Pod 을 0 개로 만들고 `v2` 의 Pod 은 3 개로 만든다.
    - `v1` : Pod 2개 (2/3) → Pod 0개 (0/3)
    - `v2` : Pod 1개 (1/3) → Pod 3개 (3/3) (신규버전 전환)
- 오류가 있다면 `v1` 의 Pod 을 다시 3개로 되돌리고 `v2` 의 Pod 은 0 개로 만든다.
    - `v1` : Pod 2개 (2/3) → Pod 3개 (3/3) (원상복구)
    - `v2` : Pod 1개 (1/3) → Pod 0개 (0/3)

<br>

