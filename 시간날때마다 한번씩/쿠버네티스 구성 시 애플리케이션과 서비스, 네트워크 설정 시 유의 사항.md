## 쿠버네티스 구성 시 애플리케이션과 서비스, 네트워크 설정 시 유의 사항



**애플리케이션을 서비스와 대응하는 형태로 설정**

- 애플리케이션과 서비스가 정확하게 대응되도록 설정해야 한다. 디플로이먼트와 서비스가 일대일 대응되도록 하는 규칙이 정해진 것은 없다. 하지만 쿠버네티스에서는 애플리케이션을 직접 호출하는 것이 아니라 서비스를 통해 호출하는 구조다. 즉 서비스가 애플리케이션과 대응되는 구조다.
- 만약에 호출해야 할 서비스가 애플리케이션에 정확하게 대응되지 않고 다수의 애플리케이션을 매칭해서 호출해야 하는 경우가 있다면 이런 경우는 메시지 큐를 통해서 애플리케이션들을 매칭시켜주는 것이 의미적으로도 기능적으로도 적합한 선택이다.
- 즉, 애플리케이션 내에서 호출해야 하는 마이크로 서비스가 여러개 일 때 이것이 서비스 들로 모두 매칭시키기 어렵다면, 메시지 큐를 사용한다.
- 만약, 다수의 서비스에 호출을 해야 하는 경우 불필요하게 애플리케이션을 나눠서 서비스를 일일이 지정하기보다는 이런 경우는 메시지 큐를 통해 다수의 서비스를 매칭시켜주는게 더 적절한 방식이다.
    - 만약 애플리케이션에서 여러개의 서비스로 트래픽을 전송해야 하는 경우 이 경우 메시지 큐를 사용하는게 의미상으로도 더 적절하다.

<br>



**기본적으로 같은 클러스터에서는 모든 애플리케이션이 서로 통신이 가능하다.**

- 네임스페이스가 다르더라도 네임스페이스를 명시하면 다른 네임스페이스를 호출이 가능하다.
- 개발계와 운영계를 접근할수 없도록 해야할 경우 NetworkPolicy 를 정의해서 해결 가능
- 개발계와 운영계를 다른 클러스터로 구분해서 보안 목적이 아니더라도 리소스 관리 측면에서 관리가 잘 되도록 물리적으로 분리해서 구성하는 것도 권장된다.

<br>



**세션에 의존하기보다는 모든 요청이 독립적으로 이뤄질 수 있도록 구현**

- 쿠버네티스에서는 가급적 Session Affinity 같은 설정은 가급적 안하는 것이 좋다. 만약 정말 필요한 경우라면 보조하는 경우로 사용하는 것이 좋다. 예를 들어 어떤 요청에 대한 응답을 로컬하게 캐시하는 경우 Session Affinity 설정을 통해 캐시 히트를 높여주는 경우처럼 보조적인 용도로 사용하는 경우는 권장된다.
- Session Affinity 를 사용하면 일종의 Sticky Session 을 설정이 가능해진다. 쉽게 설명하면 호출하는 클라이언트의 IP를 기준으로 네트워크 라우팅 대상을 고정시키는 Sticky Session 설정이 가능하다. 예를 들어 들어오는 모든 요청에 대해 같은 파드가 하는 호출은 항상 같은 파드로 라우팅 되도록 고정하는 경우를 예로 들 수 있다.
- 이런 설정들은 쿠버네티스의 스케일 조정이나 지속적 배포, 업데이트에 제약을 주게 될 가능성이 높다. 따라서 모든 요청들은 어떤 파드가 다른 Target 파드로 호출을 하든가 하는 영향이 없도록 Stateless 하고 독립적으로 구성을 하는게 중요하다.
- 레거시 애플리케이션을 쿠버네티스 환경으로 마이그레이션 하는 과정에서 이런 부분에 대한 고민이 생길 수 있고 Session Affinity 가 해결을 해줄 것 처럼 보이기도 하는데, Session Affinity 같은 경우 일반적으로 설정을 안하는 것이 좋다. 정말 필요한 경우에만 사용하자.

<br>



**호출 대상의 스케일이나 가용성을 고려하지 말고, 호출 자체에 집중할 것**

- 쿠버네티스 환경에서의 애플리케이션을 개발할 때는 호출하는 쪽 (클라이언트) 에서는 가급적 심플하게 호출하는 것이 오히려 쿠버네티스의 잠점을 잘 살리는 호출 방식이다.
- 호출 시 항상 괜찮은 상태이고 라우팅이 잘이뤄지고 로드밸런싱이 잘 되고 있다는 가정 하에 호출하는 식으로 단순하게 호출하는 것이 좋다. 호출하는 쪽 (클라이언트) 측의 코드에서는 retry count, timeout 등을 지정해주고 호출이 실패했을 때의 예외 처리 정도만 신경써주면 된다.
- 쿠버네티스의 애플리케이션 상태관리, 네트워크 라우팅, 이런 기능들은 쿠버네티스에서 담당하는 것을 기본으로 하고 있다. 그런데 클라이언트 레벨에서는 이런 개념들을 적용할 만한 요소들이 별로 없다. 따라서 클라이언트 사이드에서 로드밸런싱을 하거나 지속적으로 다른 서버의 상태를 체크하던가 하는 활동들이 쿠버네티스에서는 구현이 불가능한 경우도 있고 비효율 적이거나 불필요한 경우가 많다.

<br>



**쿠버네티스의 네트워크 기능이 충분하지 않다면 별도 플러그인을 고려**

- 쿠버네티스의 네트워크 구성이 꽤 잘 이루어져 있지만 프로덕션 레벨에서는 부족하게 느껴질 만한 부분들이 있다. 네트워크 구성에 대해 다양한 요구사항들이 생길 경우 가급적 쿠버네티스의 바닐라 네트워크를 그대로 사용하기보다는 istio 와 같은 별도의 네트워크 플러그인을 사용하는게 권장된다.
- 쿠버네티스 레벨에서의 로드밸런싱 같은 경우 알아서 다 해준다고는 하지만 알고리즘이 단순하기에 뭔가 가중치를 준다던가 하는 제어를 하는 것이 어렵고 서킷 브레이커 설정 같은 경우 쿠버네티스 네트워크 레벨에서는 지원해주는 것이 없다. 따라서 클라이언트 레벨에서 어느 정도는 따로 챙겨야 한다.

